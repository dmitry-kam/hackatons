# Комментарий к задаче

Беглый поиск по алгоритмам для решения чего-то подобного результата не дал. 

При таком небольшом **n** (_days_) и **k** (_inverstors_) можно просто решить перебором, 
выстроив дерево с ветвями глубиной не более n. После чего посчитать суммы вероятностей
по последним узлам по инвесторам. Алгоритмическая сложность **вроде как** n!/(n-k)!,
так как последовательности это размещения из теории вероятностей.

Так как задача решается на время, то решил действовать путем, который показался более 
очевидным, чем заниматься перебором и продолжать искать академический алгоритм.

### Тезисы по моему алгоритму:

- т.к. функции у нас по условию неубывающие, то условно делим их на линейные и нелинейные
- считаем угловой коэффициент (slope) функции, взяв начальную и конечную точку
- приводим в градусы через арктангенс
- считаем общую сумму вероятностей по инвесторам
- начинаем с того, что в первый день просто берем самого благосклонного инвестора (у которого самая большая сумма)
- в следующий день алгоритм сводится к тому, чтобы проверить:
    - если угловой коэффициент текущей точки и точки предыдущего дня меньше, чем угловой коэффициент функции в общем, то значит мы ушли ниже порога, когда стоит заниматься этим инвестором дальше. В таком случае "сбрасываем" его и на новой итерации вновь берем самого благосклонного
    - считаем возможный максимум (по его дню) за исключением текущего инвестора
    - считаем разницу углов между функцией, где этот максимум располагается, и текущей
    - если в текущий день переключение на нового инвестора в абсолюте (разница увеличения вероятности) выгоднее, а угол не сильно расходится (то есть благосклонность инвестора не сильно ниже), то идем на встречу к нему, но нашего лидера не сбрасываем со счетов - даем подумать и на следущей итерации возвращаемся к нему
    - проходим таким образом **n** итераций (O(n)) и получаем сумму вероятностей

Наверняка, если прогнать больше тестов, то этот алгоритм можно будет завалить, но на имеющихся на 
платформе тестах все отработало. Задача решена за 5:39 на 16 очков (которые непонятно за что выдаются,
но видимо за расходы по памяти и возможно объем кода). Быстрее оказался участник с +7 очков за 03:15:09, 
эффективнее участница с +117 за 18:44:38. После решения вернулся на 1 место в рейтинге.

